{
  parserClass="net.kenro.ji.jin.purescript.parser.PSParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="PS"
  psiImplClassSuffix="Impl"
  psiPackage="net.kenro.ji.jin.purescript.psi"
  psiImplPackage="net.kenro.ji.jin.purescript.psi.impl"

  elementTypeHolderClass="net.kenro.ji.jin.purescript.psi.PSTypes"
  elementTypeClass="net.kenro.ji.jin.purescript.psi.PSElementType"
  tokenTypeClass="net.kenro.ji.jin.purescript.psi.PSTokenType"

  psiImplUtilClass="net.kenro.ji.jin.purescript.psi.impl.PSPsiImplUtil"

  generateTokenAccessors=true

  tokens = [
    DATA      = "data"
    TYPE      = "type"
    NEWTYPE   = "newtype"
    FOREIGN   = "foreign"
    IMPORT    = "import"
    INFIXL    = "infixl"
    INFIXR    = "infixr"
    INFIX     = "infix"
    CLASS     = "class"
    INSTANCE  = "instance"
    MODULE    = "module"
    CASE      = "case"
    OF        = "of"
    IF        = "if"
    THEN      = "then"
    ELSE      = "else"
    DO        = "do"
    LET       = "let"
    TRUE      = "true"
    FALSE     = "false"
    IN        = "in"
    WHERE     = "where"
    FORALL    = "forall"
    QUALIFIED = "qualified"
    HIDING    = "hiding"
    AS        = "as"
    DARROW    = "=>"
    ARROW     = "->"
    LARROW    = "<-"
    EQ        = "="
    DOT       = "."
    BACKSLASH = "\\"
    SEMI      = ";"
    DCOLON    = "::"
    TICK      = "`"
    PIPE      = "|"
    COMMA     = ","
    LPAREN    = "("
    RPAREN    = ")"
    LBRACK    = "["
    RBRACK    = "]"
    LCURLY    = "{"
    RCURLY    = "}"
    DDOT      = ".."

    ID = "ID"
    MLCOMMENT = "MLCOMMENT"
    SLCOMMENT = "SLCOMMENT"
    PROPER_NAME = "PROPER_NAME"
    OPERATOR = "OPERATOR"
    STRING = "STRING"
    NATURAL = "NATURAL"
    FLOAT = "FLOAT"
    ERROR = "ERROR"
    STRING_ERROR = "STRING_ERROR"
    STRING_ESCAPED = "STRING_ESCAPED"
    STRING_GAP = "STRING_GAP"



//    ID = "regexp:\w+"
//    PROPER_NAME = "regexp:\w+"
//    space='regexp:\s+'
  ]
}

PSFile ::= item_*

private item_ ::= ModuleDeclaration Declaration?

// Module

ModuleDeclaration ::=
  'module' ModuleName DeclarationRefs? 'where'

ModuleName ::=
  PROPER_NAME ['.' ModuleName]

ModuleExportModuleName ::= 'module' PROPER_NAME

// Export & Import List

DeclarationRefType ::= PROPER_NAME

DeclarationRefId ::= ID

DeclarationRefTypeConstructorItem ::=
  PROPER_NAME [',' PROPER_NAME]

DeclarationRefTypeConstructor ::=
    DeclarationRefType LPAREN (DDOT | DeclarationRefTypeConstructorItem) RPAREN

DeclarationRefList ::=
     (DeclarationRefTypeConstructor
     | DeclarationRefType
     | ModuleExportModuleName
     | DeclarationRefId ) [',' DeclarationRefList]

DeclarationRefs ::=
  '(' DeclarationRefList ')'

// Declarations

Declaration ::=
    ImportDeclaration
  | DataDeclaration

// Imports

ImportDeclaration ::=
  'import' ImportName

ImportName ::=
  PROPER_NAME ['.' ImportName] DeclarationRefs?

// Data Declaration

DataDeclaration ::=
  'data' DeclarationRefType DeclarationRefIdList?


DeclarationRefIdList ::=
  DeclarationRefId [ DeclarationRefIdList ]