{
  parserClass="net.kenro.ji.jin.purescript.parser.PSParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="PS"
  psiImplClassSuffix="Impl"
  psiPackage="net.kenro.ji.jin.purescript.psi"
  psiImplPackage="net.kenro.ji.jin.purescript.psi.impl"

  elementTypeHolderClass="net.kenro.ji.jin.purescript.psi.PSTypes"
  elementTypeClass="net.kenro.ji.jin.purescript.psi.PSElementType"
  tokenTypeClass="net.kenro.ji.jin.purescript.psi.PSTokenType"

  psiImplUtilClass="net.kenro.ji.jin.purescript.psi.impl.PSPsiImplUtil"

  generateTokenAccessors=true

  tokens = [
    DATA      = "data"
    TYPE      = "type"
    NEWTYPE   = "newtype"
    FOREIGN   = "foreign"
    IMPORT    = "import"
    INFIXL    = "infixl"
    INFIXR    = "infixr"
    INFIX     = "infix"
    CLASS     = "class"
    INSTANCE  = "instance"
    MODULE    = "module"
    CASE      = "case"
    OF        = "of"
    IF        = "if"
    THEN      = "then"
    ELSE      = "else"
    DO        = "do"
    LET       = "let"
    TRUE      = "true"
    FALSE     = "false"
    IN        = "in"
    WHERE     = "where"
    FORALL    = "forall"
    QUALIFIED = "qualified"
    HIDING    = "hiding"
    AS        = "as"
    DARROW    = "=>"
    ARROW     = "->"
    LARROW    = "<-"
    EQ        = "="
    DOT       = "."
    BACKSLASH = "\\"
    SEMI      = ";"
    DCOLON    = "::"
    TICK      = "`"
    PIPE      = "|"
    COMMA     = ","
    LPAREN    = "("
    RPAREN    = ")"
    LBRACK    = "["
    RBRACK    = "]"
    LCURLY    = "{"
    RCURLY    = "}"
    DDOT      = ".."

    ID = "ID"
    MLCOMMENT = "MLCOMMENT"
    SLCOMMENT = "SLCOMMENT"
    PROPER_NAME = "PROPER_NAME"
    OPERATOR = "OPERATOR"
    STRING = "STRING"
    NATURAL = "NATURAL"
    FLOAT = "FLOAT"
    ERROR = "ERROR"
    STRING_ERROR = "STRING_ERROR"
    STRING_ESCAPED = "STRING_ESCAPED"
    STRING_GAP = "STRING_GAP"


    // uncomment to play with live preview
    PROPER_NAME = "regexp:[A-Z]\w+"
    ID = "regexp:\w+"
    space='regexp:\s+'
  ]
}

PSFile ::= item_*

private item_ ::= ModuleDeclaration Declarations?

// Module

ModuleDeclaration ::=
  'module' ModuleName DeclarationRefs? 'where'

ModuleName ::=
  PROPER_NAME ['.' ModuleName]

ModuleExportModuleName ::= 'module' PROPER_NAME

// Export & Import List

DeclarationRefType ::= PROPER_NAME

DeclarationRefId ::= ID

DeclarationRefTypeConstructorItem ::=
  PROPER_NAME [',' PROPER_NAME]

DeclarationRefTypeConstructor ::=
    DeclarationRefType LPAREN (DDOT | DeclarationRefTypeConstructorItem) RPAREN

DeclarationRefList ::=
     (DeclarationRefTypeConstructor
     | DeclarationRefType
     | ModuleExportModuleName
     | DeclarationRefId ) [',' DeclarationRefList]

DeclarationRefs ::=
  '(' DeclarationRefList ')'

// Declarations

Declarations ::=
  Declaration Declarations?

Declaration ::=
    ImportDeclaration
  | DataDeclaration
  | TypeDeclaration
  | NewTypeDeclaration

// Imports

ImportDeclaration ::=
  'import' ImportName

ImportName ::=
  PROPER_NAME ['.' ImportName] DeclarationRefs?

// Data Declaration

DataDeclaration ::=
  'data' DeclarationRefType DeclarationRefIdList? (EQ DataDeclarationItemList )?

DataDeclarationItem ::=
  DeclarationRefTypeList DeclarationRefIdList? LPAREN? DataDeclarationBody? DataDeclarationTypeOnly? RPAREN?

DataDeclarationItemList ::=
   DataDeclarationItem [PIPE DataDeclarationItemList ]

DeclarationRefIdList ::=
  DeclarationRefId DeclarationRefIdList?

DeclarationRefTypeList ::=
  DeclarationRefType DeclarationRefTypeList?

DataDeclarationBody ::=
   LCURLY  DataDeclarationTypeDefinitionList?  RCURLY

DataDeclarationTypeOnly ::=
( LPAREN? ( ParenthesisedTypeThenIdList | ParenthesisedIdList ) RPAREN? [ARROW  LPAREN? ( ParenthesisedTypeThenIdList | ParenthesisedIdList ) RPAREN? ] )

DataDeclarationTypeDefinition ::=
   ID DCOLON ( LPAREN? ( ParenthesisedTypeThenIdList | ParenthesisedIdList ) RPAREN? [ARROW  LPAREN? ( ParenthesisedTypeThenIdList | ParenthesisedIdList ) RPAREN? ] )

ParenthesisedTypeThenIdList ::=
    (LPAREN? ParenthesisedDeclarationRefTypeList ParenthesisedDeclarationRefIdList? RPAREN?)

ParenthesisedIdList ::=
    (LPAREN? ParenthesisedDeclarationRefIdList RPAREN?)

DataDeclarationTypeDefinitionList ::=
   DataDeclarationTypeDefinition [ ',' DataDeclarationTypeDefinitionList ]

ParenthesisedDeclarationRefIdList ::=
  LPAREN? DeclarationRefId RPAREN? ParenthesisedDeclarationRefIdList?

ParenthesisedDeclarationRefTypeList ::=
  LPAREN? DeclarationRefType RPAREN? ParenthesisedDeclarationRefTypeList?

// Type Declaration

TypeDeclaration ::=
   'type' DeclarationRefType DeclarationRefIdList? (EQ LPAREN? DataDeclarationItemList RPAREN?)?

// NewType Declaration

NewTypeDeclaration ::=
   'newtype'


